<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>Realtime Localization System (RTLS) Introduction</title>
<link rel="stylesheet" href="../../../web_support/strapdown/v/0.2/fonts/ubuntu-regular-woff.css"><link rel="stylesheet" href="../../../web_support/strapdown/v/0.2/fonts/glyphicons-halflings-regular.css"><link rel="stylesheet" href="../../../web_support/strapdown/v/0.2/themes/united2.min.css"><link rel="stylesheet" href="../../../web_support/strapdown/v/0.2/themes/bootstrap-responsive.min.css"><link rel="stylesheet" href="../../../web_support/strapdown/v/0.2/strapdown.css"><link rel="shortcut icon" type="image/x-icon" href="../../../.metadata/favicon.ico"></head>

<!-- START PRE -->






<!-- END PRE -->

<body style=""><div class="container"><nav class="navbar navbar-default navbar-static-top"><div class="container-fluid"> <div class="navbar-header">  <div id="headline" class="navbar-brand">Realtime Localization System (RTLS) Introduction</div> </div> </div></nav><div class="container"><div class="row row-offcanvas row-offcanvas-left"><div class="col-xs-12 col-sm-9" id="content"><h1 class="body-heading" id="introduction">Introduction<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#introduction"></a></h1><div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Note
</span></h4>
<p>  Please note that this lab only applies to SDK 3.20.00. We are in the
  process of revamping our RTLS SimpleLink Academy Lab content and plan to
  release at the end of October 2019 to update for SDK 3.30.00.</p>
<p>  For updated documentation RTLS for SDK 3.30.00 please refer to the <a href="http://dev.ti.com/tirex/explore/node?node=AKS5oOWR4K-9ijBgtvOWNw__krol.2c__LATEST">TI BLE-Stack User's Guide</a>.</p>
</div>
<p>This module is an introduction to the Real Time Localization System (RTLS)
Toolbox as well as its suite of PC tools. The RTLS toolbox is a collection of
tools for localization, direction finding, and secure range bounding.</p>
<p>The RTLS architecture consists of software running on the host (PC) and the
embedded device (CC26xx). Embedded RTLS nodes are controlled by the host via
commands over UART. Host software is responsible for sending commands to the
embedded nodes and collecting the results. The suite of host software is
referred to as the RTLS Node Manager.</p>
<p>It is assumed that the reader has a basic knowledge of embedded tool chains and
general C and Python programming concepts.</p>
<p>This lab is based on the <code>rtls_master</code>  <code>rtls_slave</code>  and <code>rtls_passive</code> projects
that are part of the SimpleLink™ CC2640R2 SDK
(<a href="http://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK">http://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK</a>).</p>
<p>This lab will focus on running the out of box demos, setting up the host Python
environment, and getting started with data collection using Angle of Arrival
(AoA) or Time of Flight (ToF).</p>
<h1 class="body-heading" id="prerequisites">Prerequisites<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#prerequisites"></a></h1><h3 class="body-heading" id="software-for-desktop-development">Software for desktop development<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#software-for-desktop-development"></a></h3><ul>
<li>SimpleLink™ CC2640R2 SDK (<a href="http://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK">http://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK</a>)</li>
<li>Those listed under the Dependencies section of the <a href="http://dev.ti.com/tirex/#/?link=Software%2FSimpleLink%20CC2640R2%20SDK
%2FDocuments%2FRelease%20Notes">CC2640R2 SDK Release
Notes</a></li>
<li>Python 3.7 or higher</li>
<li><a href="https://git-scm.com/downloads">Git bash</a></li>
<li>RTLS known issues page on <a href="https://e2e.ti.com/support/wireless-connectivity
/bluetooth/f/538/t/770218">E2E</a>. Apply all relevant fixes from this page.</li>
<li><a href="https://www.google.com/chrome/">Chrome</a> web browser</li>
</ul>
<h3 class="body-heading" id="hardware">Hardware<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#hardware"></a></h3><p>This module requires the following kits:</p>
<ul>
<li>3x <a href="http://www.ti.com/tool/LAUNCHXL-CC2640R2">CC2640R2-LAUNCHXL</a></li>
<li>1x <a href="http://www.ti.com/tool/BOOSTXL-AoA">BOOSTXL-AoA</a></li>
</ul>
<h3 class="body-heading" id="recommended-reading">Recommended reading<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#recommended-reading"></a></h3><p>These chapters in the <a href="http://dev.ti.com/tirex/explore/node?node=AKS5oOWR4K-9ijBgtvOWNw__krol.2c__LATEST">TI BLE-Stack User's Guide</a></p>
<ul>
<li>Getting Started</li>
<li>The CC2640R2F SDK Platform</li>
<li>Application</li>
<li>BLE-Stack</li>
<li>RTLS Toolbox</li>
<li>Network Processor Interface (NPI)</li>
</ul>
<p>Getting started with <a href="http://dev.ti.com/tirex/#/?link=
Development%20Tools%2FKits%20and%20Boards%2FAngle%20of%20Arrival%20BoosterPack
%2FGetting%20Started">AoA booster pack</a></p>
<p>Project readme files:</p>
<ul>
<li><a href="http://dev.ti.com/tirex/#/?link=Software%2FSimpleLink%20CC2640R2%20SDK
%2FExamples%2FDevelopment%20Tools%2FCC2640R2%20LaunchPad%2Fblestack%2Frtls_master">rtls_master</a></li>
<li>All relevant information to <code>rtls_slave</code> and <code>rtls_passive</code> is contained in
the <code>rtls_master</code> readme</li>
<li><code>rtls_agent</code> Readme located in <strong>&lt;SimpleLink CC2640R2 SDK&gt; → tools
→ blestack → rtls_agent</strong> folder within the CC2640R2 SDK. This will be
covered in detail in Task 2.</li>
</ul>
<h1 class="body-heading" id="getting-started-ndash-desktop">Getting started – Desktop<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#getting-started-ndash-desktop"></a></h1><h2 class="body-heading" id="install-the-software">Install the Software<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#install-the-software"></a></h2><ol>
<li>Run the SimpleLink CC2640R2 SDK installer.</li>
<li>Install Python 3.7 or later from the <a href="https://www.python.org/downloads/">Python Download page</a>.</li>
<li>Setup the Python environment as described in the README.html in the
<strong>&lt;SimpleLink CC2640R2 SDK&gt; → tools → blestack → rtls_agent</strong> folder.</li>
<li>If a bash environment doesn't exist on your system, install <a href="https://git-scm.com/downloads">Git bash</a></li>
</ol>
<p>This gives you:</p>
<ul>
<li>The SDK with TI-RTOS included at <code>&lt;SIMPLELINK_CC2640R2_SDK_INSTALL_DIR&gt;</code> which
defaults to <code>C:\ti\simplelink_cc2640r2_sdk_x_xx_xx_xx</code>.</li>
<li>Python 3.7 environment with all dependencies required by the RTLS Node Manager</li>
</ul>
<h2 class="body-heading" id="modify-load-the-software">Modify/Load the software<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#modify-load-the-software"></a></h2><ul>
<li>Load Board #1 + <a href="http://www.ti.com/tool/BOOSTXL-AoA">BOOSTXL-AoA</a> with
<code>rtls_passive</code> project: <br> <strong>&lt;SimpleLink CC2640R2 SDK&gt; → examples
→ rtos → CC2640R2_LAUNCHXL → blestack → rtls_passive</strong></li>
<li>Load Board #2 with <code>rtls_slave</code> project: <br> <strong>&lt;SimpleLink CC2640R2 SDK&gt;
→ examples → rtos → CC2640R2_LAUNCHXL → blestack →
rtls_slave</strong></li>
<li>Load Board #3 with <code>rtls_master</code> project: <br> <strong>&lt;SimpleLink CC2640R2 SDK&gt;
→ examples → rtos → CC2640R2_LAUNCHXL → blestack →
rtls_master</strong></li>
</ul>
<div class="bs-callout bs-callout-warning "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Building the projects
</span></h4>
<p>  Be sure to build both the stack and application before loading projects.
  Note that the <code>rtls_passive</code> uses the micro BLE-Stack setup as a connection
  monitor, therefore it does not have a separate stack project.</p>
</div>
<p>The following tasks will show you how to get started with data collection
using the RTLS toolbox. This lab will focus on the RTLS Toolbox as a whole and
the Python based PC environment. Subsequent labs will cover AoA or ToF specific
topics.</p>
<h1 class="body-heading" id="localization-techniques">Localization Techniques<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#localization-techniques"></a></h1><p>A Real Time Localization System can be defined as a system capable of
determining the position of a target within a defined physical area in real
time. The physical area is normally defined through deployment of
reference/locator nodes.</p>
<p>There are two fundamentally different approaches to location finding:</p>
<p><strong>Trilateration</strong>, where you know the distance between a reference node and a
target node. <code>Time of Flight</code> gives you the distance from the receiver to the transmitter.</p>
<center>
<div class="modal-pop" style="cursor:zoom-in;"><img src="resources/trilateration.png" alt="Trilateration" class="img-responsive"></div>
</center>

<p><strong>Triangulation</strong>, where you know the direction from a reference node to a target
node. <code>Angle of Arrival</code> is a technique that can be used to measure the angle
from the receiver to the transmitter.</p>
<center>
<div class="modal-pop" style="cursor:zoom-in;"><img src="resources/triangulation.png" alt="Triangulation" class="img-responsive"></div>
</center>

<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">What is a node?
</span></h4>
<p>  A node in this case is referred to as a localization capable embedded device.
  For the demos in the SDK, nodes are LaunchPads</p>
</div>
<h1 class="body-heading" id="rtls-toolbox-introduction">RTLS Toolbox Introduction<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#rtls-toolbox-introduction"></a></h1><p>In the <a href="#localization-techniques">Localization Techniques</a>,
we discussed how multiple AoA nodes can combine angle
information to perform triangulation and how multiple ToF nodes can combine
distance information to perform trilateration. It is important to remember in
the pictures above, it is not possible for one single node to localize an
object using the TI sample applications. A single AoA node only produces one
angle, and a single ToF node only produces one distance. These by nature, are
ambiguous measurements. If there are at least two nodes providing AoA or ToF
data, then localization can occur. This requires a fourth device that is
capable of combining the samples from the individual nodes and finding the
intersection.</p>
<p>The intersection between the angles (AoA) or circles (ToF) is the estimated
location of the device. An overview of the topology is shown below. In the
diagram below, the black, blue, and red boxes represent CC2640R2 LaunchPads
while the grey box is a PC.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/network.png" alt="RTLS Network" class="img-responsive"></div><p></p>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Time of Flight performs which of the following localization techniques?
</span></h4>
<div class="quiz-toolbar"><div>
<input type="radio" id="q1.0" class="answer-wrong" name="quiz-1"><label for="q1.0" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; From a ToF measurement a circle with radius = ToF reported distance may be drawn around then node that performed the measurement.&lt;/p&gt;
">Trilateration, ToF provides a distance measurement </label>
<input type="radio" id="q1.1" class="answer-right" name="quiz-1"><label for="q1.1" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; ToF can only measure distance, not angles.&lt;/p&gt;
">Triangulation, ToF measures the angle and distance of the incident wave </label>
</div></div>
</div>
<p>For a comprehensive presentation of the RTLS toolbox and its software components,
please see the <a href="http://dev.ti.com/tirex/explore/node?node=AKS5oOWR4K-9ijBgtvOWNw__krol.2c__LATEST">TI BLE-Stack User's Guide</a></p>
<h1 class="body-heading" id="rtls-roles-and-topology">RTLS Roles and Topology<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#rtls-roles-and-topology"></a></h1><p>Each node in an RTLS network utilizes the software components listed above
in a different way to perform a specific task related to localization. There are
three examples: <code>rtls_master</code>, <code>rtls_slave</code>, and <code>rtls_passive</code>. The capabilities
of these examples are explained below.</p>
<div class="bs-callout bs-callout-info "><h4><span style="vertical-align: middle;">RTLS Master
</span></h4>
<p>The RTLS master runs a full BLE-Stack and acts as a BLE central device.
It will scan and connect to the RTLS slave over BLE. Once a connection is
established the RTLS Master will do the following:</p>
<ul>
<li>Share the connection parameters (access address, master sleep clock accuracy,
and CRC init) with the PC.</li>
<li>Use the BLE link to share ToF and AoA parameters with the peripheral device.</li>
<li>Implements the ToF master role</li>
<li>The RTLS master does not send out AoA packets, but configures the slave to do so.</li>
</ul>
</div>
<div class="bs-callout bs-callout-success "><h4><span style="vertical-align: middle;">RTLS Slave
</span></h4>
<p>The RTLS slave runs a full BLE-Stack and acts as a BLE peripheral device. This is
the device that is to be located. The slave device will advertise and enter a
connection with the RTLS Master.</p>
<ul>
<li>Advertises special string to be detected by <code>rtls_master</code> (covered in detail in Task 3)</li>
<li>BLE-Stack peripheral role</li>
<li>Implements ToF slave role</li>
<li>Sends data packets with AoA tone embedded using Constant Tone Extension (CTE)</li>
<li>Wireless/battery operated, not connected to PC</li>
</ul>
</div>
<div class="bs-callout bs-callout-warning "><h4><span style="vertical-align: middle;">RTLS Passive
</span></h4>
<p>The RTLS passive does not actively participate in the BLE connection between
the RTLS master and slave. Instead, it uses the Micro BLE-Stack in
connection monitoring mode to follow the connection. To do this, the passive
device relies on the Master to distribute the connection parameters once a
connection is formed. The passive node does the following:</p>
<ul>
<li>Implement ToF passive role</li>
<li>Receives packets with CTE and performs in-phase and quadrature component (IQ) sampling</li>
<li>Uses Micro BLE-Stack in Connection Monitoring mode to follow connection between master and slave</li>
</ul>
</div>
<div class="bs-callout bs-callout-danger "><h4><span style="vertical-align: middle;">PC/Central Processing Node
</span></h4>
<p>The PC node is responsible for controlling the embedded RTLS nodes by sending
commands and processing events. In the SDK, this is realized by a combination
of a Python layer that implements the UNPI master role and a rtls_agent_cli server
that translates UNPI commands to a socket interface that is used by the GUI
Composer application running in the browser. In a final product, these algorithms
may be implemented on an embedded device or even perhaps the RTLS master node.</p>
<p>The PC implements the following roles in Python:</p>
<ul>
<li>UNPI master</li>
<li>COM port interface</li>
<li>Implementation of RTLS UNPI subsystem/command set</li>
<li>rtls_agent_cli server</li>
</ul>
<p>The PC implements the following roles in GUI Composer/Javascript:</p>
<ul>
<li>rtls_agent_cli client on localhost</li>
<li>Graphing and logging data from rtls_agent_cli</li>
<li>Parsing JSON objects to extract RTLS data</li>
<li>Issue commands to RTLS nodes via rtls_agent_cli to UNPI conversion</li>
<li>Enumerate devices</li>
<li>Distribute connection parameters to passive nodes</li>
</ul>
</div>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Quiz!
</span></h4>
<p><strong> Is it possible to have multiple RTLS passive devices in a network? </strong></p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q2.2" class="answer-right" name="quiz-2"><label for="q2.2" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; Since it is a passive role and not a participant any number of devices can listen to a connection so long as they have parameters.&lt;/p&gt;
">Yes, the PC program will distribute connection information to any device that has RTLS capabilities of passive. </label>
<input type="radio" id="q2.3" class="answer-wrong" name="quiz-2"><label for="q2.3" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; This is incorrect, any device with connection parameters (access address, crc init, etc) can follow the connection.&lt;/p&gt;
">No, only one device can track the connection between master and slave due to timing requirements. </label>
</div></div>
<p><strong> Why would multiple passive devices be desirable? (select all that apply) </strong></p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q3.4" class="answer-right" name="quiz-3"><label for="q3.4" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; The passive node is capable of reporting AoA or ToF data.&lt;/p&gt;
">RTLS passive node can sample IQ data for AoA as well as ToF tick data as well as RSSI from connection </label>
<input type="radio" id="q3.5" class="answer-wrong" name="quiz-3"><label for="q3.5" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; From the question above, it is possible to scale to many passive devices.&lt;/p&gt;
">It is not possible to have multiple passives </label>
<input type="radio" id="q3.6" class="answer-right" name="quiz-3"><label for="q3.6" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; ToF is statistical, so having more samples increases the confidence with which the measurement is made.&lt;/p&gt;
">More passives provide more samples which can increase the robustness of the post processing algorithms </label>
<input type="radio" id="q3.7" class="answer-right" name="quiz-3"><label for="q3.7" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; Spreading out the nodes reduces the chance that the direct path will not be observed.&lt;/p&gt;
">Passive nodes can provide spatial diversity, which provides immunity to reflections </label>
</div></div>
</div>
<h1 class="body-heading" id="task-1-ndash-running-the-rtls-demo">Task 1 – Running the RTLS Demo<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#task-1-ndash-running-the-rtls-demo"></a></h1><p>In this task, we will use the pre-compiled <code>rtls_agent_cli.exe</code> located at <br>
<strong>&lt;SimpleLink CC2640R2 SDK&gt; → tools → blestack → rtls_agent</strong>
It is recommended to familiarize yourself with the readme in the same folder
before starting.</p>
<ol>
<li><p>Apply any fixes from the RTLS known issues page on <a href="https://e2e.ti.com/
support/wireless-connectivity/bluetooth/f/538/t/770218">E2E</a></p>
</li>
<li><p>See the image below for a recommended layout of the nodes during evaluation,
this is a 2D image where all devices are laying on a flat surface "pointing"
as shown in the picture. In this case each node should be placed on a box
so that it does not sit directly on the ground. Note that a desk environment
generally has sub-optimal RF conditions and should be avoided.
Take note that the below image shows the <code>rtls_passive</code> in AoA configuration.
By default the SDK will configure <code>rtls_passive</code> as for ToF, see the bonus below
for more info. Note the BOOSTXL-AOA should not be used for ToF.</p>
</li>
</ol>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/suggested_layout.png" alt="RTLS Physical Layout" class="img-responsive"></div><p></p>
<ol>
<li><p>Build the projects and flash the LaunchPads as described in <a href="#modify-load-the-software">Modify/Load the software</a></p>
</li>
<li><p>Run the pre-compiled <code>rtls_agent_cli.exe</code>, press 'a' to auto detect the LaunchPads connected to your PC.
This will trigger the <code>rtls_agent_cli.exe</code> to send <code>RTLS_CMD_IDENTIFY</code> to each node.</p>
<ul>
<li>Once the nodes are identified, press enter to start the agent.</li>
<li>Note that it is normal to receive NoRsp from ports if they are not programmed with RTLS software.
Additionally, the COM ports used by the JTAG debugger will not respond, so NoRsp is expected there as well.</li>
<li>As long as <code>RTLS_MASTER</code> and <code>RTLS_PASSIVE</code> are detected, then it is okay to move on.</li>
</ul>
</li>
<li><p>Navigate to <a href="https://dev.ti.com/gallery">TI GUI Composer Gallery</a> and search for "RTLS Monitor"
Use version <code>0.9.4</code>.</p>
<ul>
<li>Select the RTLS_Monitor and click on it, this will open it in the browser view of GUI composer. (We recommend using the latest version of Chrome.)</li>
<li>Note that each version of RTLS Monitor corresponds to a specific version of the SDK.</li>
<li>At the time of writing <code>0.9.4</code> is latest and corresponds to the <code>CC2640R2 SDK 3.20</code></li>
</ul>
</li>
<li><p>Click the connect button, this will connect to the rtls_agent_cli running on localhost.</p>
<div class="bs-callout bs-callout-danger "><h4><span style="vertical-align: middle;">What to do if default port is in use already?
</span></h4>
<p> If after you click the connect button the RTLS_Monitor, you see Closed as part of the logging msg as shown below.
 </p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/default_port_not_working.png" alt="OOB port does not work" class="img-responsive"></div>
 Then you can change the port by following the steps below:<p></p>
<ol>
<li><p>Close the rtls_agent_cli.exe</p>
</li>
<li><p>Type <code>winpty ./rtls_agent_cli.exe -p 8777</code> in git bash to change the port number to 8777 or anyother number you would like.</p>
</li>
<li><p>Change the port number used in RTLS_Monitor to the one you choose. For example:
</p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/change_port_on_gui.png" alt="Change Port Number on GUI" class="img-responsive"></div><p></p>
</li>
</ol>
</div>
</li>
<li><p>On success, you should be able to see graph window displaying sample data.</p>
<ul>
<li>It will take ~30 seconds before the graph starts showing data.</li>
<li>We will cover more about what is happening during that time and what it
takes to setup a RTLS network in Task 3.</li>
<li>If evaluating in ToF mode, you should not move the nodes until the GUI
starts receiving data, because ToF is calibrating. Once the GUI starts
graphing, it is okay to move the nodes around. The default calibration
distance is 1m.</li>
</ul>
</li>
</ol>
<div class="bs-callout bs-callout-success "><h4><span style="vertical-align: middle;">Automatic RTLS
</span></h4>
<p>   If the "Automatic RTLS" checkbox is enabled then the GUI will connect to the
   first RTLS slave device it finds and will immediately start AoA or ToF.
   When this box is unchecked it is possible to scan and select the slave
   device manually via Bluetooth Address listed in the "Remote devices" combobox.</p>
<p>   This is helpful if there are multiple RTLS slaves in the area.</p>
</div>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Bonus
</span></h4>
<p>Define <code>RTLS_LOCATIONING_AOA</code> in all three example projects. (For <code>rtls_master</code>
and <code>rtls_slave</code>, it is found in <code>build_config.opt</code>. For <code>rtls_passive</code>, define
it in the preprocessor defines in the project properties.) Repeat the steps above.
What changed?</p>
</div>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Quiz!
</span></h4>
<p><strong> What localization technique does the out of the box software employ?</strong></p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q4.8" class="answer-right" name="quiz-4"><label for="q4.8" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; By default the SW operates in distance mode and gives distance values&lt;/p&gt;
">Time of Flight </label>
<input type="radio" id="q4.9" class="answer-wrong" name="quiz-4"><label for="q4.9" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; AoA can be enabled by defining &lt;code&gt;RTLS_LOCATIONING_AOA&lt;/code&gt; in &lt;code&gt;build_config.opt&lt;/code&gt; (master, slave) or project settings (passive)&lt;/p&gt;
">Angle of Arrival </label>
<input type="radio" id="q4.10" class="answer-wrong" name="quiz-4"><label for="q4.10" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; This is not a valid RTLS technique&lt;/p&gt;
">Angle of Flight </label>
</div></div>
<p><strong> Review the log, what devices are providing ToF distance measurements?</strong></p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q5.11" class="answer-right" name="quiz-5"><label for="q5.11" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; RTLS master implements ToF master which will measure distance.&lt;/p&gt;
">rtls_master </label>
<input type="radio" id="q5.12" class="answer-wrong" name="quiz-5"><label for="q5.12" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; RTLS slave implements ToF slave which does not report distance (generally because this device is battery powered not connected to PC)&lt;/p&gt;
">rtls_slave </label>
<input type="radio" id="q5.13" class="answer-right" name="quiz-5"><label for="q5.13" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; RTLS passive implements ToF passive which will measure distance.&lt;/p&gt;
">rtls_passive </label>
</div></div>
<p><strong> What is the format of the individual logs being sent between the rtls_agent_cli server and GUI Composer?</strong></p>
<div class="quiz-toolbar"><div>
<input type="radio" id="q6.14" class="answer-wrong" name="quiz-6"><label for="q6.14" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; JSON is used instead&lt;/p&gt;
">YAML </label>
<input type="radio" id="q6.15" class="answer-right" name="quiz-6"><label for="q6.15" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; Correct, the rtls_agent_cli server translates from UNPI serial data on the COM port to JSON before sending to GUI composer.&lt;/p&gt;
">JSON </label>
<input type="radio" id="q6.16" class="answer-wrong" name="quiz-6"><label for="q6.16" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; JSON is used instead&lt;/p&gt;
">XML </label>
</div></div>
</div>
<div class="bs-callout bs-callout-danger "><h4><span class="glyphicon glyphicon-exclamation-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Assessing RTLS performance using the out of the box demos
</span></h4>
<p>The RTLS demos provided by TI are intended for evaluation use only
and serve as a starting point for localization development.
Better performance and accuracy can be achieved by utilizing the foundational
demo toolkit provided by TI and developing advanced, customized algorithms to
process AoA and ToF data. See the AoA and ToF specific labs for detailed
information on demo results that can be used as a performance baseline as well
as tips on improving performance.</p>
<p>The demo you have run, is not optimized for performance. It instead serves as a
starting point for localization development.
It is possible to achieve much better performance and accuracy than is seen here
by developing advanced algorithms to process AoA and ToF data.
TI is actively looking into algorithm development, and encourages their
customers to do so too. This is a strong way of differentiating a localization
product.
See the AoA and ToF specific labs for more discussion and explanation of the
results</p>
</div>
<h1 class="body-heading" id="task-2-ndash-use-rtls-node-manager-directly">Task 2 – Use RTLS Node Manager Directly<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#task-2-ndash-use-rtls-node-manager-directly"></a></h1><p>This task will bypass the GUI Composer application and interact directly with
the RTLS Python APIs to collect data. This gives power to the developer to define
custom behavior of the RTLS network and control the devices directly.
Specifically, this will cover setting up the required Python dependencies and
running the <code>rtls_example.py</code> template script described in the SDK.</p>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-hand-right gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Assumptions and Notation
</span></h4>
<p>Before starting this task the following is assumed</p>
<ul>
<li>A command prompt supporting bash or Git bash is open and running.</li>
<li>Unix style slashes will be used throughout. If it is necessary to run these
steps in the Windows Command Prompt (<code>cmd.exe</code>), then <code>/</code> should be replaced
with <code>\</code>.</li>
<li>Various command prompts will search your <a href="https://en.wikipedia.org/wiki/PATH_(variable)">System Path variable</a>
to find Python. If you have a pre-existing Python version in your path this
may be selected over the newly installed version. To prevent mixing the two
up, we will use virtual environments.</li>
<li>We assume that Mac users don't have another instance of Python 3 installed.
If this is not the case, then based on the <code>PATH</code> variable an older version
of Python may be selected with invoking the <code>python3</code> command. Be sure to
invoke the correct version of Python.</li>
<li>Here we re-hash some of the instructions from the rtls_agent/readme.html,
if you already followed it, some steps may be redundant.</li>
</ul>
</div>
<ol>
<li>Install Python per steps in <a href="#install-the-software">Getting started</a></li>
<li>Open a command prompt (<a href="https://git-scm.com/downloads">Git Bash</a> is recommended)</li>
<li><p>Create a Python virtual environment</p>
<ul>
<li>Navigate to the SDK folder (e.g. <code>C:\ti\simplelink_cc2640r2_sdk_x_xx_xx_xx\tools\blestack\rtls_agent</code>)</li>
<li>Execute <code>py -3.7 -m venv .venv</code> (windows) or <code>python3 -m venv .venv</code> (mac).</li>
<li>This will create a folder called <code>.venv</code>
in the current directory that includes a copy of the python interpreter and a
sandbox for installing packages.</li>
<li>Activate virtual environment using <code>source .venv/Scripts/activate</code> (bash) or
<code>.venv\Scripts\activate.bat</code> (Windows cmd)</li>
<li>Observe that when a venv is activated <code>(.venv)</code> will appear before each cmd
prompt</li>
<li>Notice that once the virtual environment is activated, the <code>python</code> command
will use the local Python interpreter in the venv.
See <a href="https://virtualenv.pypa.io/en/latest/">Virtual Environments</a> for more info.</li>
</ul>
</li>
<li><p>Install required Python Dependencies into the newly created virtual
environment</p>
<ul>
<li>Execute <code>python -m pip --proxy www.proxy.com install -r requirements.dev.txt</code></li>
<li>Note that above <code>--proxy www.proxy.com</code> is only required if behind a proxy.</li>
<li><code>www.proxy.com</code> is an example of a proxy. It should be replaced with
the web address of your specific proxy if applicable.</li>
<li>This will install the required Python packages that are needed by the RTLS
Python suite (these are listed in <code>requirements.dev.txt</code>).</li>
</ul>
</li>
<li><p>Open the <code>examples/rtls_example.py</code>, go to line 44, and edit the line
<code>my_nodes = [RTLSNode('COM17', 115200), RTLSNode('COM12', 115200)]</code> to use
the COM ports of the master and passive LaunchPads.</p>
<ul>
<li>Be sure to have closed <code>rtls_agent_cli</code> before doing so to free up the COM ports.</li>
</ul>
</li>
<li><p>Save the file and run it using <code>python -u examples/rtls_example.py</code>.</p>
<ul>
<li>The script will detect if AoA or ToF mode is enabled, and then connect, pair,
and start AoA or ToF based on which one is supported.</li>
<li>From here the code will print out localization data in a loop. It can be
killed with the keyboard interrupt (ctrl+c)</li>
<li>See below for sample output (note that the addresses and COM ports will be
different). After the expected output below the nodes will report AoA or ToF
data depending on how they are configured.</li>
</ul>
</li>
</ol>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Pip and requirements files
</span></h4>
<p>The RTLS and UNPI layers of the of the rtls_agent are now bundled as separate
python packages. This is why there is a <code>requirements.txt</code> and a
<code>requirements.dev.txt</code>. Using <code>requirements.txt</code> will trigger the contents
of <code>/rtls</code> and <code>/unpi</code> to be installed as read-only.
Alternatively <code>requirements.dev.txt</code> will set these packages up to be
editable. It is recommended to <code>requirements.dev.txt</code> during development, and
<code>requirements.txt</code> once the packages are finalized.</p>
</div>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_1')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_1" class="lang-diff hljs">54:6C:0E:9F:12:27 TOF_MASTER, RTLS_MASTER
54:6C:0E:83:3A:A4 CM, TOF_PASSIVE, RTLS_PASSIVE
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_IDENTIFY", "payload": {"capabilities": {"CM": true, "AOA_TX": false, "AOA_RX": false, "TOF_SLAVE": false, "TOF_PASSIVE": true, "TOF_MASTER": false, "RTLS_SLAVE": false, "RTLS_MASTER": false, "RTLS_PASSIVE": true}, "identifier": "54:6C:0E:83:3A:A4"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_IDENTIFY", "payload": {"capabilities": {"CM": false, "AOA_TX": false, "AOA_RX": false, "TOF_SLAVE": false, "TOF_PASSIVE": false, "TOF_MASTER": true, "RTLS_SLAVE": false, "RTLS_MASTER": true, "RTLS_PASSIVE": false}, "identifier": "54:6C:0E:9F:12:27"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"eventType": 0, "addrType": 0, "addr": "54:6C:0E:83:3F:3D", "rssi": -52, "dataLen": 11, "data": "0A:09:52:54:4C:53:53:6C:61:76:65"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN_STOP", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_CONNECT", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_CONN_PARAMS", "payload": {"accessAddress": 2480792542, "connInterval": 160, "hopValue": 8, "mSCA": 0, "currChan": 8, "chanMap": [255, 255, 255, 255, 31], "crcInit": 6270394}}
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_CONN_PARAMS", "payload": {"status": "RTLS_SUCCESS"}}
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_CONNECT", "payload": {"status": "RTLS_SUCCESS"}}
</code></pre></div></div>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Why is it recommended to create a virtual Python environment (select all that apply)?
</span></h4>
<div class="quiz-toolbar"><div>
<input type="radio" id="q7.17" class="answer-right" name="quiz-7"><label for="q7.17" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; Different projects may have conflicting requirements, using venv keeps them sandboxed.&lt;/p&gt;
">Install required packages locally</label>
<input type="radio" id="q7.18" class="answer-wrong" name="quiz-7"><label for="q7.18" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; It is possible to run RTLS from the global Python env.&lt;/p&gt;
">RTLS scripts require it </label>
<input type="radio" id="q7.19" class="answer-right" name="quiz-7"><label for="q7.19" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; If there are multiple Python interpreters installed on your system. This will copy the correct interpreter into the venv&lt;/p&gt;
">Get copy of interpreter </label>
</div></div>
</div>
<h1 class="body-heading" id="task-3-ndash-building-custom-rtls-python-scripts">Task 3 – Building Custom RTLS Python Scripts<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#task-3-ndash-building-custom-rtls-python-scripts"></a></h1><p>With the environment setup, it is time for us to use Python directly to control
the RTLS nodes. The goal of this task is to explain the RTLS PC software and
to walk through setting up a RTLS network.</p>
<div class="alert alert-info "><p> You might want to make a copy of the default rtls_example.py so it is
preserved. Save it with another name like <code>rtls_example_old.py</code> as a backup.</p>
</div>
<h3 class="body-heading" id="rtls-node-manager-python-overview">RTLS Node Manager Python Overview<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#rtls-node-manager-python-overview"></a></h3><p>First, we will briefly discuss the important layers of the Python solution and
their role.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_2')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_2" class="lang-diff hljs">/rtls_agent
    /rtls/
        /rtls/
            rtlsmanager.py - Class to manage multiple nodes in an RTLS network.
                             Subscribes to incoming data from the nodes, routes
                             outgoing data to each of the nodes. Distributes
                             connection parameters from master node to any
                             connected passive nodes when an connection is
                             established. Handles messages from rtls_agent_cli server
                             if one is provided.

            rtlsnode.py -    Class that implements the basic functionality of a node
                             in an RTLS network. This class will query the embedded
                             device connected to it and determine its capabilities.
                             Essentially this assigns a role in an RTLS context to
                             a COM port.

            ss_rtls.py       Defines the commands in the RTLS UNPI subsystem.
                             This file will define builder classes for the various
                             UNPI commands that the RTLS subsystem supports.

    /unpi/
        serialnode.py - Thread that manages serial communication from COM ports.
                        to higher layers.
                        Queues up messages and sends them to parser.
        unpiparser.py - Parser for Unified Network Processor Interface messages.
                        Implements UNPI frame format packing/unpacking.
</code></pre></div></div>
<h3 class="body-heading" id="rtls-python-program-template">RTLS Python Program Template<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#rtls-python-program-template"></a></h3><p>It is recommended to build RTLS based Python applications on top of the
<code>RTLSManager</code> class within rtlsmanager.py. Together with the the <code>RTLSNode</code>
class this forms the RTLS API set. The <code>rtls_example.py</code> from the previous task
shows how perform basic initialization of the RTLSNodes and RTLSManager as well
as setting up the networking and collecting localization data.</p>
<p>Here we highlight some of the important parts of the example:</p>
<p>First, construct an instance of the RTLSNode class for the master and passive
device connected to PC. The first parameter is the user/UART COM port, and the
second is the baudrate which defaults to <code>115200</code>.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_3')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_3" class="lang-python hljs">my_nodes = [RTLSNode(<span class="hljs-string">'COM14'</span>, <span class="hljs-number">115200</span>), RTLSNode(<span class="hljs-string">'COM47'</span>, <span class="hljs-number">115200</span>)]
</code></pre></div></div>
<p>Instantiate the RTLSManager will the newly created nodes, but do not connect
a rtls_agent_cli.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_4')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_4" class="lang-python hljs">manager = RTLSManager(my_nodes, websocket_port=<span class="hljs-keyword">None</span>)
</code></pre></div></div>
<p>Create a subscriber instance, and add it to the manager. Essentially this tells
the manager to add messages it receives to the example programs queue to be
processed. Tell the manager to automatically distribute connection parameters
to all of the passive nodes. Then start the manager.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_5')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_5" class="lang-python hljs">subscriber = manager.create_subscriber()
<span class="hljs-comment"># Tell the manager to automatically distribute connection parameters</span>
manager.auto_params = <span class="hljs-keyword">True</span>
<span class="hljs-comment"># Start RTLS Node threads, Serial threads, and manager thread</span>
manager.start()
</code></pre></div></div>
<p>Poll the capabilities of each node, assign master and create list of passives.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_6')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_6" class="lang-python hljs"><span class="hljs-comment"># Wait until nodes have responded to automatic identify command and get reference</span>
<span class="hljs-comment"># to single master RTLSNode and list of passive RTLSNode instances</span>
master_node, passive_nodes, failed = manager.wait_identified()
</code></pre></div></div>
<p>Now that we have instantiated the classes, and got the capabilities of the
nodes, we are ready to create the main loop.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_7')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_7" class="lang-python hljs"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
    <span class="hljs-comment"># Get messages from manager</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Pend on activity from one of the nodes with a given timeout.</span>
        identifier, msg_pri, msg = subscriber.pend(block=<span class="hljs-keyword">True</span>, timeout=<span class="hljs-number">0.05</span>).as_tuple()

        <span class="hljs-comment"># We received data from one of the nodes</span>
        <span class="hljs-comment"># First determine which node sent the information.</span>
        from_node = node_msg.identifier

        <span class="hljs-comment"># Print the message as JSON, map MASTER and PASSIVE based on identifier (BD_ADDR)</span>
        <span class="hljs-keyword">if</span> sending_node <span class="hljs-keyword">in</span> passive_nodes:
            print(f<span class="hljs-string">"PASSIVE: {identifier} --&gt; {msg.as_json()}"</span>)
        <span class="hljs-keyword">else</span>:
            print(f<span class="hljs-string">"MASTER: {identifier} --&gt; {msg.as_json()}"</span>)

        <span class="hljs-comment"># Perform further processing here.</span>

    <span class="hljs-keyword">except</span> queue.Empty:
        <span class="hljs-keyword">pass</span>
</code></pre></div></div>
<h3 class="body-heading" id="rtls-network-setup-procedure">RTLS Network Setup Procedure<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#rtls-network-setup-procedure"></a></h3><p>The preceding code snippets in this task form a template program built on
top of the <code>RTLSNode</code> and <code>RTLSManager</code> classes. At this point you should have
a basic understanding of RTLS classes. Next we will cover the minimum commands
required to setup an RTLS network.</p>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-question-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">In which Python file would you find the UNPI command definitions for the ToF?
</span></h4>
<div class="quiz-toolbar"><div>
<input type="radio" id="q8.20" class="answer-wrong" name="quiz-8"><label for="q8.20" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; This file is not currently used because the current solution does not ultilze the CM subsystem.&lt;/p&gt;
">ss_cm.py </label>
<input type="radio" id="q8.21" class="answer-wrong" name="quiz-8"><label for="q8.21" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; This file does not exist, both AoA and ToF are part of the RTLS subsystem.&lt;/p&gt;
">rtls_aoa.py </label>
<input type="radio" id="q8.22" class="answer-right" name="quiz-8"><label for="q8.22" class="quiz-label " data-toggle="tooltip" data-html="true" data-container="body" data-placement="auto top" data-trigger="click" title="" data-original-title="&lt;p&gt; This file defines the RTLS subsystem which includes AoA and ToF and their builder classes.&lt;/p&gt;
">ss_rtls.py </label>
</div></div>
</div>
<p>The embedded examples in the SDK will synchronize localization measurements on a
connection. In this case a measurement can be ToF interleaved with the BLE
connection events or AoA measuring the CTE embedded in the connection packets.
In both cases a BLE connection is a prerequisite for performing localization.
The sequence diagram below shows the UNPI commands required to establish a
connection between <code>rtls_master</code> and <code>rtls_slave</code>.</p>
<p></p><div class="modal-pop" style="cursor:zoom-in;"><img src="resources/rtls_connect_diag.png" alt="RTLS Setup Sequence Diagram" class="img-responsive"></div><p></p>
<p>As covered in the BLE connections lab, before connecting, a scan must be
performed to see if the desired device is nearby. The scanning device will
inspect the advertising and optionally the scan response data to determine if
it wishes to connect to a given advertiser. Usually the scanner is looking
for a given token or string in the broadcast data of the advertiser. The RTLS
master will look for the string <code>{'R','T','L','S','S','l','a','v','e'}</code> starting
at the 3rd byte of the slave's advertisement data. If the advertising device
matches the filter, then it will be reported to the PC/Node Manager as
<code>RTLS_CMD_SCAN</code> responses, if not, it will be discarded.</p>
<p>If the Node Manager wishes to form a connection to one of the devices in the
scan results it can tell the <code>rtls_master</code> to do so by issuing an
<code>RTLS_CMD_CONNECT</code> along with the peer device's address and address type.
The address information can be extracted from the <code>RTLS_CMD_SCAN</code> responses
coming from the master node.</p>
<p>If the connection is successful, the <code>RTLS_CMD_CONNECT</code> response will be
received with status of <code>RTLS_SUCCESS</code>. The RTLS examples do not consider a
connection to be established between master and slave until the devices have
paired and formed an L2CAP Connection Oriented Channel (CoC). The L2CAP CoC
is used to send RTLS sync related information between master and slave.
This can include AoA parameters or ToF parameters, or a command to enable AoA
or ToF.</p>
<p>Immediately after the BLE connection is established
(i.e. <code>GAP_LINK_ESTABLISHED_EVENT</code> received from the stack), the <code>rtls_master</code>
will share the connection parameters with the PC/Node Manager via
<code>RTLS_CMD_CONN_PARAMS</code>. This information is needed by the connection monitor
inside <code>rtls_passive</code> in order to follow the connection between RTLS master
and slave.</p>
<div class="bs-callout bs-callout-info "><h4><span class="glyphicon glyphicon-info-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Distributing Connection Parameters
</span></h4>
<p>  The <code>RTLSManager</code> Python class will immediately relay any connection
  parameters received (<code>RTLS_CMD_CONN_PARAMS</code>) to all of the passive nodes
  connected. This does not need to be done manually.</p>
</div>
<h3 class="body-heading" id="setting-up-rtls-network-in-python">Setting up RTLS Network in Python<a class="anchor-link glyphicon glyphicon-link" aria-hidden="true" href="#setting-up-rtls-network-in-python"></a></h3><p>Now that we understand the basics behind the RTLS network and how to set it up,
let's review how the <code>rtls_example.py</code> sample app sets up the RTLS network.
Note that the <code>rtls_example.py</code> will do some additional processing after the
network is setup based on AoA or ToF. This is outside of the scope of this lab
and will be covered in the following AoA and ToF labs respectively.</p>
<p>The commands required to setup a network belong to the RTLS UNPI subsystem and
can be found in the <code>ss_rtls.py</code> file.</p>
<p>We will use the <code>rtls_example.py</code> as a starting point. From the sections
above, we know that after the nodes are identified, we want to tell the master
to scan.</p>
<p>You can send a command to an <code>RTLSNode</code> instance by calling the builder class
associated with the command. For example, if you have an <code>RTLSNode</code> instance
called <code>master_node</code> you can tell it to scan like so:</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_8')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_8" class="lang-python hljs">  master_node.rtls.scan()
</code></pre></div></div>
<p>After telling the node to scan, you will receive scan responses, the scan
response packets are defined like this in Python:</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_9')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_9" class="lang-python hljs">struct = Struct(
    <span class="hljs-string">"eventType"</span> / Int8ul,
    <span class="hljs-string">"addrType"</span> / Enum(Int8ul),
    <span class="hljs-string">"addr"</span> / NiceBytes(ReverseBytes(Byte[<span class="hljs-number">6</span>])),
    <span class="hljs-string">"rssi"</span> / Int8sl,
    <span class="hljs-string">"dataLen"</span> / Int8ul,
    <span class="hljs-string">"data"</span> / NiceBytes(Byte[this.dataLen])
)
</code></pre></div></div>
<p>In the last section, we covered that the <code>rtls_master</code> embedded node will
only report scan responses from devices that advertise as RTLS slave.
Therefore, there isn't much need to inspect the data payload unless desired.
Instead, it is adequate to store the <code>addr</code> and <code>addrType</code> fields from the
scan response as this is needed for the connect request. Assuming you have a
node message like the one from <code>rtls_example.py</code>(see top of while True loop)
then you can parse it like this:</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_10')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_10" class="lang-python hljs"><span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_SCAN'</span> <span class="hljs-keyword">and</span> msg.type == <span class="hljs-string">'AsyncReq'</span>:
    address = msg.payload.addr
    address_type = msg.payload.addrType
</code></pre></div></div>
<p>The code above will identify a scan result message then store the address and
address type in a variable.</p>
<div class="bs-callout bs-callout-default "><h4><span class="glyphicon glyphicon-hand-right gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">Asynchronous vs Synchronous commands in UNPI
</span></h4>
<p>  You might have noticed that <code>RTLS_CMD_SCAN</code> is used to tell the node to start
  scanning, receive status, and receive scan results.
  This is possible within UNPI because each message can be one of the following
  types</p>
<ul>
<li>Synchronous request</li>
<li>Synchronous response</li>
<li>Asynchronous request</li>
</ul>
<p>In the case of <code>RTLS_CMD_SCAN</code> the message that initiates the scan on the
<code>rtls_master</code> is a synchronous request. The message that returns the status
of the scan start call is a synchronous response, and the message that
returns scan results is an asynchronous request. See the NPI chapter
in the <a href="http://dev.ti.com/tirex/explore/node?node=AKS5oOWR4K-9ijBgtvOWNw__krol.2c__LATEST">TI BLE-Stack User's Guide</a>
for more information.</p>
</div>
<p>Now, we have collected a list of scan results and are ready to connect.
First, we must wait until the <code>rtls_master</code> finishes scanning. When scanning
is complete, a message of type <code>RTLS_CMD_SCAN_STOP</code> will be sent to the PC
from the <code>rtls_master</code> node. By default, the code below will connect to the
first device that has <code>{'R','T','L','S','S','l','a','v','e'}</code> as part of the
advertising data.</p>
<p>If there may be multiple <code>rtls_slave</code> devices nearby, it is best
to specify your specific via address. If there is only one <code>rtls_slave</code> nearby
this step can be skipped.</p>
<p>If you don't know the address, you can read it from the UART
display of the slave device. Open a Serial terminal (like putty or teraterm)
on the user/UART port of the <code>rtls_slave</code> LaunchPad. Use 115200 baud, 8N1.
It should show the following text:</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_11')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_11" class="lang-diff hljs">0x546C0E833F3D
Advertising
</code></pre></div></div>
<p>Based on this, you should set the following global variable
(remove the 0x, and separate by :)</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_12')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_12" class="lang-python hljs">slave_addr = <span class="hljs-string">'54:6C:0E:83:3F:3D'</span> <span class="hljs-comment"># Slave addr should be set here</span>
</code></pre></div></div>
<p>Assuming again that we have a node message like the ones in <code>rtls_example.py</code>
the code for connecting is as below.</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_13')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_13" class="lang-python hljs"><span class="hljs-comment"># Once the scan has stopped and we have a valid address, then</span>
<span class="hljs-comment"># connect</span>
<span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_SCAN_STOP'</span>:
    <span class="hljs-keyword">if</span> slave_addr <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        <span class="hljs-keyword">if</span> address <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> address_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
            master_node.rtls.connect(address_type, address, conn_interval)
        <span class="hljs-keyword">else</span>:
            master_node.rtls.scan()
    <span class="hljs-keyword">elif</span> slave_addr <span class="hljs-keyword">in</span> scanResultList:
        i = scanResultList.index(slave_addr)
        master_node.rtls.connect(scanResultList[i + <span class="hljs-number">1</span>], scanResultList[i], conn_interval)
        scanResultList.clear()
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># If we didn't find the device, keep scanning.</span>
        master_node.rtls.scan()
</code></pre></div></div>
<p>Remember, the <code>rtls_master</code> will automatically send the connection parameters
once a BLE connection is formed with the <code>rtls_slave</code>. The <code>RTLSManager</code> python
class will intercept this and distribute it to all <code>rtls_passive</code> nodes so we
don't have to do this in our program. Upon receiving the connection parameters,
the connection monitor will begin following the connection between master and
slave. Note that it may take some time to establish a connection as this
does include LE Secure Connections pairing as well as opening an L2CAP
Connection Oriented Channel.</p>
<p>Equipped with the knowledge above, modify <code>rtls_example.py</code> to connect to
your slave device. The expected output is show here:</p>
<div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_14')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_14" class="lang-diff hljs">54:6C:0E:9F:12:27 TOF_MASTER, RTLS_MASTER
54:6C:0E:83:3A:A4 CM, TOF_PASSIVE, RTLS_PASSIVE
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_IDENTIFY", "payload": {"capabilities": {"CM": true, "AOA_TX": false, "AOA_RX": false, "TOF_SLAVE": false, "TOF_PASSIVE": true, "TOF_MASTER": false, "RTLS_SLAVE": false, "RTLS_MASTER": false, "RTLS_PASSIVE": true}, "identifier": "54:6C:0E:83:3A:A4"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_IDENTIFY", "payload": {"capabilities": {"CM": false, "AOA_TX": false, "AOA_RX": false, "TOF_SLAVE": false, "TOF_PASSIVE": false, "TOF_MASTER": true, "RTLS_SLAVE": false, "RTLS_MASTER": true, "RTLS_PASSIVE": false}, "identifier": "54:6C:0E:9F:12:27"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN", "payload": {"eventType": 0, "addrType": 0, "addr": "54:6C:0E:83:3F:3D", "rssi": -54, "dataLen": 11, "data": "0A:09:52:54:4C:53:53:6C:61:76:65"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_SCAN_STOP", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_CONNECT", "payload": {"status": "RTLS_SUCCESS"}}
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_CONN_PARAMS", "payload": {"accessAddress": 1387477511, "connInterval": 160, "hopValue": 14, "mSCA": 0, "currChan": 14, "chanMap": [255, 255, 255, 255, 31], "crcInit": 212647}}
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "SyncRsp", "subsystem": "RTLS", "command": "RTLS_CMD_CONN_PARAMS", "payload": {"status": "RTLS_SUCCESS"}}
PASSIVE: 54:6C:0E:83:3A:A4 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_CONNECT", "payload": {"status": "RTLS_SUCCESS"}}
Connection established, all systems go!!!
MASTER: 54:6C:0E:9F:12:27 --&gt; {"originator": "Nwp", "type": "AsyncReq", "subsystem": "RTLS", "command": "RTLS_CMD_CONNECT", "payload": {"status": "RTLS_SUCCESS"}}
Connection established, all systems go!!!
</code></pre></div></div>
<p>Solution is below.</p>
<div class="panel-group">
  <div class="panel panel-warning">
    <div class="panel-heading">
      <h4 class="panel-title">
        <a class="accordion-toggle collapsed" data-toggle="collapse" href="#expandable_-solution-"><p> Solution</p>
</a>
      </h4>
    </div>
    <div id="expandable_-solution-" class="panel-collapse collapse">
      <div class="panel-body"><div style="display:inline-block"><div style="display:block"><button type="button" class="btn btn-xs btn-warning float-right select-text" style="margin: 0; position: relative;" onclick="SelectText('codeBlock_15')">Select text</button></div><div class="pre-container"><pre><code id="codeBlock_15" class="lang-python hljs"><span class="hljs-keyword">import</span> queue
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> rtls <span class="hljs-keyword">import</span> RTLSManager, RTLSNode

<span class="hljs-comment"># Un-comment the below to get raw serial transaction logs</span>
<span class="hljs-comment"># import logging, sys</span>
<span class="hljs-comment"># logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,</span>
<span class="hljs-comment">#                     format='[%(asctime)s] {%(filename)s:%(lineno)d} %(levelname)s - %(message)s')</span>


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    <span class="hljs-comment"># Initialize, but don't start RTLS Nodes to give to the RTLSManager</span>
    my_nodes = [RTLSNode(<span class="hljs-string">'COM26'</span>, <span class="hljs-number">115200</span>), RTLSNode(<span class="hljs-string">'COM8'</span>, <span class="hljs-number">115200</span>)]

    <span class="hljs-comment"># Initialize references to the connected devices</span>
    master_node = <span class="hljs-keyword">None</span>
    passive_nodes = []
    address = <span class="hljs-keyword">None</span>
    address_type = <span class="hljs-keyword">None</span>
    <span class="hljs-comment"># If slave addr is None, the script will connect to the first RTLS slave</span>
    <span class="hljs-comment"># that it found. If you wish to connect to a specific device</span>
    <span class="hljs-comment"># (in the case of multiple RTLS slaves) then you may specify the address</span>
    <span class="hljs-comment"># explicitly as given in the comment to the right</span>
    slave_addr = <span class="hljs-keyword">None</span> <span class="hljs-comment">#'54:6C:0E:83:3F:3D'</span>

    <span class="hljs-comment"># connection interval in units of 1.25msec configured in connection request, default is 80 (100ms)</span>
    conn_interval = <span class="hljs-number">80</span>

    <span class="hljs-comment"># Initialize manager reference, because on Exception we need to stop the manager to stop all the threads.</span>
    manager = <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-comment"># Start an RTLSManager instance without WebSocket server enabled</span>
        manager = RTLSManager(my_nodes, websocket_port=<span class="hljs-keyword">None</span>)
        <span class="hljs-comment"># Create a subscriber object for RTLSManager messages</span>
        subscriber = manager.create_subscriber()
        <span class="hljs-comment"># Tell the manager to automatically distribute connection parameters</span>
        manager.auto_params = <span class="hljs-keyword">True</span>
        <span class="hljs-comment"># Start RTLS Node threads, Serial threads, and manager thread</span>
        manager.start()

        <span class="hljs-comment"># Wait until nodes have responded to automatic identify command and get reference</span>
        <span class="hljs-comment"># to single master RTLSNode and list of passive RTLSNode instances</span>
        master_node, passive_nodes, failed = manager.wait_identified()

        <span class="hljs-keyword">if</span> len(failed):
            print(f<span class="hljs-string">"ERROR: {len(failed)} nodes could not be identified. Are they programmed?"</span>)

        <span class="hljs-comment"># Exit if no master node exists</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> master_node:
            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">"No RTLS Master node connected"</span>)

        <span class="hljs-comment"># Combined list for lookup</span>
        all_nodes = passive_nodes + [master_node]

        <span class="hljs-comment">#</span>
        <span class="hljs-comment"># At this point the connected devices are initialized and ready</span>
        <span class="hljs-comment">#</span>

        <span class="hljs-comment"># Display list of connected devices</span>
        print(f<span class="hljs-string">"{master_node.identifier} {', '.join([cap for cap, available in master_node.capabilities.items() if available])}"</span>)

        <span class="hljs-comment"># Iterate over Passives and detect their capabilities</span>
        <span class="hljs-keyword">for</span> pn <span class="hljs-keyword">in</span> passive_nodes:
            print(f<span class="hljs-string">"{pn.identifier} {', '.join([cap for cap, available in pn.capabilities.items() if available])}"</span>)

        <span class="hljs-comment"># Send an example command to each of them, from commands listed at the bottom of rtls/ss_rtls.py</span>
        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> all_nodes:
            n.rtls.identify()

        <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
            <span class="hljs-comment"># Get messages from manager</span>
            <span class="hljs-keyword">try</span>:
                identifier, msg_pri, msg = subscriber.pend(block=<span class="hljs-keyword">True</span>, timeout=<span class="hljs-number">0.05</span>).as_tuple()

                <span class="hljs-comment"># Get reference to RTLSNode based on identifier in message</span>
                sending_node = manager[identifier]

                <span class="hljs-keyword">if</span> sending_node <span class="hljs-keyword">in</span> passive_nodes:
                    print(f<span class="hljs-string">"PASSIVE: {identifier} --&gt; {msg.as_json()}"</span>)
                <span class="hljs-keyword">else</span>:
                    print(f<span class="hljs-string">"MASTER: {identifier} --&gt; {msg.as_json()}"</span>)

                <span class="hljs-comment"># After identify is received, we start scanning</span>
                <span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_IDENTIFY'</span>:
                      master_node.rtls.scan()

                <span class="hljs-comment"># Once we start scaning, we will save the address of the</span>
                <span class="hljs-comment"># last scan response</span>
                <span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_SCAN'</span> <span class="hljs-keyword">and</span> msg.type == <span class="hljs-string">'AsyncReq'</span>:
                    address = msg.payload.addr
                    address_type = msg.payload.addrType

                <span class="hljs-comment"># Once the scan has stopped and we have a valid address, then</span>
                <span class="hljs-comment"># connect</span>
                <span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_SCAN_STOP'</span>:
                    <span class="hljs-keyword">if</span> slave_addr <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
                        <span class="hljs-keyword">if</span> address <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> address_type <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">None</span>:
                            master_node.rtls.connect(address_type, address, conn_interval)
                        <span class="hljs-keyword">else</span>:
                            master_node.rtls.scan()
                    <span class="hljs-keyword">elif</span> slave_addr <span class="hljs-keyword">in</span> scanResultList:
                        i = scanResultList.index(slave_addr)
                        master_node.rtls.connect(scanResultList[i + <span class="hljs-number">1</span>], scanResultList[i], conn_interval)
                        scanResultList.clear()
                    <span class="hljs-keyword">else</span>:
                        <span class="hljs-comment"># If we didn't find the device, keep scanning.</span>
                        master_node.rtls.scan()

                <span class="hljs-comment"># Once we are connected, then we can do stuff</span>
                <span class="hljs-keyword">if</span> msg.command == <span class="hljs-string">'RTLS_CMD_CONNECT'</span> <span class="hljs-keyword">and</span> msg.type == <span class="hljs-string">'AsyncReq'</span> <span class="hljs-keyword">and</span> msg.payload.status == <span class="hljs-string">'RTLS_SUCCESS'</span>:
                    <span class="hljs-keyword">print</span> (<span class="hljs-string">"Connection established, all systems go!!!"</span>)

            <span class="hljs-keyword">except</span> queue.Empty:
                <span class="hljs-keyword">pass</span>

    <span class="hljs-keyword">finally</span>:
        <span class="hljs-keyword">if</span> manager:
            manager.stop()
</code></pre></div></div>
</div>
    </div>
  </div>
</div><div class="bs-callout bs-callout-success "><h4><span class="glyphicon glyphicon-ok-sign gi-2x" style="vertical-align: middle; margin-right: 0.2em;"></span><span style="vertical-align: middle;">You made it to the end
</span></h4>
<p><em>Excellent</em> work!</p>
</div>
<div align="center" style="margin-top: 4em; font-size: smaller;">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="../../../web_support/cc_license_icon.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.</div>

</div><div class="col-xs-4 col-sm-2 sidebar-offcanvas bs-docs-sidebar hidden-print" id="sidebar-overview"><ul class="nav nav-stacked fixed" id="sidebar"><li><a href="#introduction">Introduction</a></li><li><a href="#prerequisites">Prerequisites</a><ul class="nav nav-stacked"><ul class="nav nav-stacked"><li><a href="#software-for-desktop-development">Software for desktop development</a></li><li><a href="#hardware">Hardware</a></li><li><a href="#recommended-reading">Recommended reading</a></li></ul></ul></li><li><a href="#getting-started-ndash-desktop">Getting started – Desktop</a><ul class="nav nav-stacked"><li><a href="#install-the-software">Install the Software</a></li><li><a href="#modify-load-the-software">Modify/Load the software</a></li></ul></li><li><a href="#localization-techniques">Localization Techniques</a></li><li><a href="#rtls-toolbox-introduction">RTLS Toolbox Introduction</a></li><li><a href="#rtls-roles-and-topology">RTLS Roles and Topology</a></li><li><a href="#task-1-ndash-running-the-rtls-demo">Task 1 – Running the RTLS Demo</a></li><li><a href="#task-2-ndash-use-rtls-node-manager-directly">Task 2 – Use RTLS Node Manager Directly</a></li><li><a href="#task-3-ndash-building-custom-rtls-python-scripts">Task 3 – Building Custom RTLS Python Scripts</a><ul class="nav nav-stacked"><ul class="nav nav-stacked"><li><a href="#rtls-node-manager-python-overview">RTLS Node Manager Python Overview</a></li><li><a href="#rtls-python-program-template">RTLS Python Program Template</a></li><li><a href="#rtls-network-setup-procedure">RTLS Network Setup Procedure</a></li><li><a href="#setting-up-rtls-network-in-python">Setting up RTLS Network in Python</a></li></ul></ul></li></ul></div></div></div></div>

<link rel="stylesheet" href="../../../web_support/highlight/styles/zenburn.css">
<script src="../../../web_support/strapdown/vendor/jquery-1.11.2.min.js"></script>
<script src="../../../web_support/strapdown/vendor/bootstrap.min.js"></script>
<script src="../../../web_support/highlight/highlight.pack.js"></script>
<script type="text/javascript">document.isPreRendered = true;</script><script src="../../../web_support/strapdown/v/0.2/strapdown.js"></script>      <div class="modal" id="imagemodal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">        <div class="vertical-alignment-helper">          <div class="modal-dialog vertical-align-center">             <div class="modal-dialog">               <div class="modal-content" style="margin-left: auto;margin-right: auto;">                 <div class="modal-body">                   <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">×</span><span class="sr-only">Close</span></button>                   <img src="" class="imagepreview img-responsive">                 </div>              </div>            </div>          </div>        </div>      </div>


</body></html>